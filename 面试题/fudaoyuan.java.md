# 猿辅导

一面：

1. 链表倒置

2. 括号的有效性

   ````wiki
   题目信息：
   给定一个字符串所表示的括号序列，包含以下字符： '(', ')', '{', '}','[' and']'， 判定是否是有效的括号序列。
   
   分析：
   1. 有效的括号序列长度是不为0的偶数，所以字符串长度为0或者为奇数是就要返回false
   2. 如果第一个字符是右括号或者最后一个字符是左括号，那么就不是有效序列，返回false
   3. 创建堆栈，遍历字符串，如果是左括号，则推入堆栈中，如果是右括号，判断当前堆栈是否为空，如果为空，返回false，否则看栈顶元素是否和该右括号匹配，如果不匹配返回false，如果匹配就将栈顶弹出，继续遍历字符串。
   4. 字符串遍历结束，判断堆栈是否是空的，如果不是空的，说明左括号数量大于右括号，不是幼小括号序列，返回false，否则返回true
   
   知识点：
   解决本题需要使用堆栈的信息，在Java中提供了stack类和Deque接口
   1. stack类 就是堆栈类
   2. Deque接口 双端队列
   将双端队列用作队列的时候，将等到FIFO行为。将元素添加到双端队列的末尾，从双端对队列的开头移除元素。从Queue接口继承的方法完全等效于Deque方法，双端队列也可以用作LIFO堆栈，应有限使用此接口而不是stack类，在将双端队列用作堆栈时，元素被推入双端队列的开头并从双端队列开头弹出。堆栈方法完全等效于Deque方法。
   ArrayDeque是Deque的紫烈，即可以实现堆栈，又可以实现队列。ArrayDeque用作堆栈时，效率逼Stack高，用作队列的时候，效率比LinkedList高，所以一般使用ArrayDeque来实现堆栈和队列的数据结构。
   ````

   ````java
   public class isValidParentheses {
   
       public boolean isValidParentheses(String str) {
           int len = str.length();
           /**
            * 字符串为null
            * 字符串长度为0
            * 字符串长度不是偶数
            * peek: 获取栈顶元素
            * pop：弹出栈顶元素
            */
           if (str == null || len == 0 || len % 2 != 0) {
               return false;
           }
   
           char start = str.charAt(0);
           char end = str.charAt(len - 1);
           if (start == '}' || end == ')' || end == ']') {
               return false;
           }
           if (start == '{' || start == '(' || start == '[') {
               return false;
           }
   
           Deque<Character> stack = new ArrayDeque<>();
   
           for (int i = 0; i < len; i++) {
               char ch = str.charAt(i);
               // 如果是左括号直接添加近堆栈
               if (ch == '{' || ch == '(' || ch == '[') {
                   stack.push(ch);
               } else if (ch == '}' || ch == ')' || ch == ']') {
                   if (stack.isEmpty()) {
                       return false;
                   } else {
                       char peek = stack.peek();
                       if (isMatch(peek, ch)) {
                           stack.pop();
                       } else {
                           return false;
                       }
                   }
               }
           }
           if (stack.isEmpty()) {
               return true;
           }
           return false;
       }
   
       private boolean isMatch(char c1, char c2) {
           return (c1 == '{' && c2 == '}' || c1 == '(' && c2 == ')' || c1 == '[' && c2 == ']');
       }
   }
   ````

3. static 关键字

   ````wiki
   static 修饰的代码称为静态代码，当JVM装载类的时候，就会执行该部分的代码块。
   static 修饰的变量称为静态变量，静态变量是随着类加载时被完全初始化的，他在内存中仅有一个，且JVM也只会为它分配一次内存，同时类所有的示例都是共享静态变量，可以直接通过类名来访问。
   static 修饰的方法称为静态方法，该方法是在类加载的时候就存在了，它不依赖于任何示例，所以static方法必须实现，也就是说他不能是抽象方法abstract
   static的局限：
   1. 只能调用static变量
   2. 只能调用static方法
   3. 不能以任何形式应用this和super
   4. static变量在定义的时候必须初始化，且初始化时间要早于非静态变量
   ````

   引申想到的概念：

   ````wiki
   接口和抽象类之间的区别：
   抽象类是从一系列相关对象中抽象出来的概念，因此反应的是事物内部共性，接口是为了满足外部调用而定义的一个功能约定，因此反映的是事物的外部特性。
   抽象类和接口之间的区别：
   1. 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；
   2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；
   3. 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
   4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。
   
   使用场景：
   1. 抽象类适合用来定义某个领域的固有属性，也就是本质，接口适合用来定义某个领域的扩展功能
   2. 当为一些类提供公共的实现代码的时，应有限考虑抽象类，因为抽象类中的非抽象方法可以被子类继承下来，使实现功能的代码更简单
   3. 当注重代码的扩展性和可维护性时候，应当优先采用接口
       1. 接口与实现他的类之间可以不存在任何参差关系，接口可以实现毫不相关类的相同行为。
       2. 接口只关心对象之间的交互方法，而不关心对象所对应的具体类。
       3. 接口是程序之间的一个协议，比抽象类的使用更安全、清晰。一般使用接口的情况更多一些。
       
   更简单的说法：
   1. 一个Person,有眼镜、肤色，这些描述一个人的特征可以定义在抽象类当中，而一个人的行为如打篮球可以定义在接口当中。
   ````

4. 项目中数据库是如何设计的

5. 说一下压测是如何做得

